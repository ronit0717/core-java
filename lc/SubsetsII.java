/* Solution 1, TC = O(NLogN) to sort + O(N*2^(N-1)) to recursively get all subsets
SC = O(2^N) as 2^N =  N-C-0 + N-C-1 + N-C-2 + ......... + N-C-N
The solution involves, getting the resultSet of the immediate next index
Incase of duplicates, it becomes necessary to avoid duplicates in the new resultset
To avoid duplicates in result set, we need to skip appending current num to the result set generated by second previous index

2,2,2,3
      [][3] => prev set size = 2, this is the result set for index 3
    [][3][2][3,2] => prevSetSize = 4, , this is the result set for index 2
  [][3][2][3,2][2,2][3,2,2] => skipped 2 times, this is the result set for index 1
[][3][2][3,2][2,2][3,2,2][2,2,2][3,2,2,2] => skipped 4 times, this is the result set for index 0
*/
class Solution {
    
    int prevSetSize = 0;
    int prev = -1;
    
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        return subsetUtil(nums, 0);
    }
    
    private List<List<Integer>> subsetUtil(int[] nums, int index) {
        List<List<Integer>> res = null;
        
        if (index == nums.length) {
            res = new LinkedList<>();
            List<Integer> list = new LinkedList<>();
            res.add(list);
            prevSetSize = 1;
            return res;
        }
        
        res = subsetUtil(nums, index+1);
        
        int skipCount;
        if (index != (nums.length - 1) && prev == nums[index]) {
            skipCount = prevSetSize;
        } else {
            prev = nums[index];
            skipCount = 0;
        }
        prevSetSize = res.size();
        
        for (int i = skipCount; i < prevSetSize; i++) {
            List<Integer> list = new LinkedList(res.get(i));
            list.add(nums[index]);
            res.add(list);
        }
        return res;
    }
}

/**
 * Solution 2: Striver's solution.
 */
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<Integer> candidates = new LinkedList();
        List<List<Integer>> result = new LinkedList();
        evaluate(0, nums, candidates, result);
        return result;
    }

    private void evaluate(int index, int[] nums, List<Integer> candidates, List<List<Integer>> result) {
        result.add(new LinkedList<>(candidates)); //adding of current size
        if (index >= nums.length) {
            return;
        }
        int prev = -11;
        for (int i = index; i < nums.length; i++) {
            int curr = nums[i];
            if (prev == curr) {
                continue; //skip
            }
            candidates.add(curr);
            evaluate(i + 1, nums, candidates, result); //pick
            candidates.removeLast();
            prev = nums[i];
        }
    }
}